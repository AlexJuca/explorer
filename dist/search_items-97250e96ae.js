searchNodes=[{"doc":"Documentation for Explorer .","ref":"Explorer.html","title":"Explorer","type":"module"},{"doc":"Gets the default backend for the current process.","ref":"Explorer.html#default_backend/0","title":"Explorer.default_backend/0","type":"function"},{"doc":"Sets the current process default backend to backend . The default backend is stored only in the process dictionary. This means if you start a separate process, such as Task , the default backend must be set on the new process too. Examples iex&gt; Explorer . default_backend ( Lib.CustomBackend ) Explorer.PolarsBackend iex&gt; Explorer . default_backend ( ) Lib.CustomBackend","ref":"Explorer.html#default_backend/1","title":"Explorer.default_backend/1","type":"function"},{"doc":"The behaviour for Explorer backends. Each backend is a module with DataFrame and Series submodules that match the respective behaviours for each.","ref":"Explorer.Backend.html","title":"Explorer.Backend","type":"module"},{"doc":"The behaviour for DataFrame backends.","ref":"Explorer.Backend.DataFrame.html","title":"Explorer.Backend.DataFrame","type":"behaviour"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:arrange/2","title":"Explorer.Backend.DataFrame.arrange/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:distinct/3","title":"Explorer.Backend.DataFrame.distinct/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dtypes/1","title":"Explorer.Backend.DataFrame.dtypes/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dummies/2","title":"Explorer.Backend.DataFrame.dummies/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:filter/2","title":"Explorer.Backend.DataFrame.filter/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_map/1","title":"Explorer.Backend.DataFrame.from_map/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:head/2","title":"Explorer.Backend.DataFrame.head/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:join/4","title":"Explorer.Backend.DataFrame.join/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:mutate/2","title":"Explorer.Backend.DataFrame.mutate/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:n_cols/1","title":"Explorer.Backend.DataFrame.n_cols/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:n_rows/1","title":"Explorer.Backend.DataFrame.n_rows/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:names/1","title":"Explorer.Backend.DataFrame.names/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:pull/2","title":"Explorer.Backend.DataFrame.pull/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:read_csv/10","title":"Explorer.Backend.DataFrame.read_csv/10","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:rename/2","title":"Explorer.Backend.DataFrame.rename/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:sample/3","title":"Explorer.Backend.DataFrame.sample/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:select/3","title":"Explorer.Backend.DataFrame.select/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:shape/1","title":"Explorer.Backend.DataFrame.shape/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:slice/3","title":"Explorer.Backend.DataFrame.slice/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:tail/2","title":"Explorer.Backend.DataFrame.tail/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:take/2","title":"Explorer.Backend.DataFrame.take/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_map/2","title":"Explorer.Backend.DataFrame.to_map/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:write_csv/4","title":"Explorer.Backend.DataFrame.write_csv/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:colname/0","title":"Explorer.Backend.DataFrame.colname/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:df/0","title":"Explorer.Backend.DataFrame.df/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:result/1","title":"Explorer.Backend.DataFrame.result/1","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:series/0","title":"Explorer.Backend.DataFrame.series/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:t/0","title":"Explorer.Backend.DataFrame.t/0","type":"type"},{"doc":"The behaviour for series backends.","ref":"Explorer.Backend.Series.html","title":"Explorer.Backend.Series","type":"behaviour"},{"doc":"","ref":"Explorer.Backend.Series.html#c:add/2","title":"Explorer.Backend.Series.add/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:all_equal?/2","title":"Explorer.Backend.Series.all_equal?/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:argsort/2","title":"Explorer.Backend.Series.argsort/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cast/2","title":"Explorer.Backend.Series.cast/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:count/1","title":"Explorer.Backend.Series.count/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cum_max/2","title":"Explorer.Backend.Series.cum_max/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cum_min/2","title":"Explorer.Backend.Series.cum_min/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cum_sum/2","title":"Explorer.Backend.Series.cum_sum/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:distinct/1","title":"Explorer.Backend.Series.distinct/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:divide/2","title":"Explorer.Backend.Series.divide/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:dtype/1","title":"Explorer.Backend.Series.dtype/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:eq/2","title":"Explorer.Backend.Series.eq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:fill_missing/2","title":"Explorer.Backend.Series.fill_missing/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:filter/2","title":"Explorer.Backend.Series.filter/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:from_list/2","title":"Explorer.Backend.Series.from_list/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:get/2","title":"Explorer.Backend.Series.get/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:gt/2","title":"Explorer.Backend.Series.gt/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:gt_eq/2","title":"Explorer.Backend.Series.gt_eq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:head/2","title":"Explorer.Backend.Series.head/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:length/1","title":"Explorer.Backend.Series.length/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:lt/2","title":"Explorer.Backend.Series.lt/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:lt_eq/2","title":"Explorer.Backend.Series.lt_eq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:map/2","title":"Explorer.Backend.Series.map/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:max/1","title":"Explorer.Backend.Series.max/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:mean/1","title":"Explorer.Backend.Series.mean/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:median/1","title":"Explorer.Backend.Series.median/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:min/1","title":"Explorer.Backend.Series.min/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:multiply/2","title":"Explorer.Backend.Series.multiply/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:n_distinct/1","title":"Explorer.Backend.Series.n_distinct/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:neq/2","title":"Explorer.Backend.Series.neq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:peaks/2","title":"Explorer.Backend.Series.peaks/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:pow/2","title":"Explorer.Backend.Series.pow/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:quantile/2","title":"Explorer.Backend.Series.quantile/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:reverse/1","title":"Explorer.Backend.Series.reverse/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:rolling_max/4","title":"Explorer.Backend.Series.rolling_max/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:rolling_mean/4","title":"Explorer.Backend.Series.rolling_mean/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:rolling_min/4","title":"Explorer.Backend.Series.rolling_min/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:rolling_sum/4","title":"Explorer.Backend.Series.rolling_sum/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sample/3","title":"Explorer.Backend.Series.sample/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:slice/3","title":"Explorer.Backend.Series.slice/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sort/2","title":"Explorer.Backend.Series.sort/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:std/1","title":"Explorer.Backend.Series.std/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:subtract/2","title":"Explorer.Backend.Series.subtract/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sum/1","title":"Explorer.Backend.Series.sum/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:tail/2","title":"Explorer.Backend.Series.tail/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:take/2","title":"Explorer.Backend.Series.take/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:take_every/2","title":"Explorer.Backend.Series.take_every/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:to_list/1","title":"Explorer.Backend.Series.to_list/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:var/1","title":"Explorer.Backend.Series.var/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#t:df/0","title":"Explorer.Backend.Series.df/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:dtype/0","title":"Explorer.Backend.Series.dtype/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:s/0","title":"Explorer.Backend.Series.s/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:t/0","title":"Explorer.Backend.Series.t/0","type":"type"},{"doc":"The DataFrame struct and API.","ref":"Explorer.DataFrame.html","title":"Explorer.DataFrame","type":"module"},{"doc":"Arranges/sorts rows by columns. Examples A single column name will sort ascending by that column: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . arrange ( df , [ &quot;a&quot; ] ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 3 , 1 , 2 ] &gt; You can also sort descending: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . arrange ( df , [ { &quot;a&quot; , :desc } ] ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] a string [ &quot;c&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 2 , 1 , 3 ] &gt; Atoms will be converted to the string column name: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . arrange ( df , a : :desc ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] a string [ &quot;c&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 2 , 1 , 3 ] &gt; Sorting by two columns sorts them in the order they are entered: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . arrange ( df , [ &quot;total&quot; , &quot;country&quot; ] ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 ] year integer [ 2010 , 2014 , 2013 , 2012 , 2011 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;AFGHANISTAN&quot; , &quot;AFGHANISTAN&quot; , &quot;AFGHANISTAN&quot; , &quot;AFGHANISTAN&quot; , &quot;...&quot; ] total integer [ 2308 , 2675 , 2731 , 2933 , 3338 , &quot;...&quot; ] solid_fuel integer [ 627 , 1194 , 1075 , 1000 , 1174 , &quot;...&quot; ] liquid_fuel integer [ 1601 , 1393 , 1568 , 1844 , 2075 , &quot;...&quot; ] gas_fuel integer [ 74 , 74 , 81 , 84 , 84 , &quot;...&quot; ] cement integer [ 5 , 14 , 7 , 5 , 5 , &quot;...&quot; ] gas_flaring integer [ 0 , 0 , 0 , 0 , 0 , &quot;...&quot; ] per_capita float [ 0.08 , 0.08 , 0.09 , 0.1 , 0.12 , &quot;...&quot; ] bunker_fuels integer [ 9 , 9 , 9 , 9 , 9 , &quot;...&quot; ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . arrange ( df , total : :asc , country : :desc ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 ] year integer [ 2010 , 2012 , 2011 , 2013 , 2014 , &quot;...&quot; ] country string [ &quot;ZIMBABWE&quot; , &quot;ZIMBABWE&quot; , &quot;ZIMBABWE&quot; , &quot;ZIMBABWE&quot; , &quot;ZIMBABWE&quot; , &quot;...&quot; ] total integer [ 2121 , 2125 , 2608 , 3184 , 3278 , &quot;...&quot; ] solid_fuel integer [ 1531 , 917 , 1584 , 1902 , 2097 , &quot;...&quot; ] liquid_fuel integer [ 481 , 1006 , 888 , 1119 , 1005 , &quot;...&quot; ] gas_fuel integer [ 0 , 0 , 0 , 0 , 0 , &quot;...&quot; ] cement integer [ 109 , 201 , 136 , 162 , 177 , &quot;...&quot; ] gas_flaring integer [ 0 , 0 , 0 , 0 , 0 , &quot;...&quot; ] per_capita float [ 0.15 , 0.15 , 0.18 , 0.21 , 0.22 , &quot;...&quot; ] bunker_fuels integer [ 7 , 9 , 8 , 9 , 9 , &quot;...&quot; ] &gt;","ref":"Explorer.DataFrame.html#arrange/2","title":"Explorer.DataFrame.arrange/2","type":"function"},{"doc":"Takes distinct rows by a selection of columns. Examples By default will return unique values of the requested columns: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . distinct ( df , [ &quot;year&quot; , &quot;country&quot; ] ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 2 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] &gt; If keep_all? is set to true , then the first value of each column not in the requested columns will be returned: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . distinct ( df , [ &quot;year&quot; , &quot;country&quot; ] , true ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , &quot;...&quot; ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , &quot;...&quot; ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , &quot;...&quot; ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , &quot;...&quot; ] cement integer [ 5 , 177 , 2598 , 0 , 204 , &quot;...&quot; ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , &quot;...&quot; ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , &quot;...&quot; ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , &quot;...&quot; ] &gt; A callback on the dataframe's names can be passed instead of a list (like select/3 ): iex&gt; df = Explorer.DataFrame . from_map ( %{ x1 : [ 1 , 3 , 3 ] , x2 : [ &quot;a&quot; , &quot;c&quot; , &quot;c&quot; ] , y1 : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . distinct ( df , &amp; String . starts_with? ( &amp;1 , &quot;x&quot; ) ) # Explorer.DataFrame &lt; [ rows : 2 , columns : 2 ] x1 integer [ 1 , 3 ] x2 string [ &quot;a&quot; , &quot;c&quot; ] &gt;","ref":"Explorer.DataFrame.html#distinct/3","title":"Explorer.DataFrame.distinct/3","type":"function"},{"doc":"Gets the dtypes of the dataframe columns. Examples iex&gt; df = Explorer.DataFrame . from_map ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , 2 ] } ) iex&gt; Explorer.DataFrame . dtypes ( df ) [ :float , :integer ]","ref":"Explorer.DataFrame.html#dtypes/1","title":"Explorer.DataFrame.dtypes/1","type":"function"},{"doc":"Turns a set of columns to dummy variables.","ref":"Explorer.DataFrame.html#dummies/2","title":"Explorer.DataFrame.dummies/2","type":"function"},{"doc":"Subset rows using column values. Examples You can pass a mask directly: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . filter ( df , Explorer.Series . gt ( df [ &quot;b&quot; ] , 1 ) ) # Explorer.DataFrame &lt; [ rows : 2 , columns : 2 ] a string [ &quot;b&quot; , &quot;c&quot; ] b integer [ 2 , 3 ] &gt; Including a list: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . filter ( df , [ false , true , false ] ) # Explorer.DataFrame &lt; [ rows : 1 , columns : 2 ] a string [ &quot;b&quot; ] b integer [ 2 ] &gt; Or you can invoke a callback on the dataframe: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . filter ( df , &amp; Explorer.Series . gt ( &amp;1 [ &quot;b&quot; ] , 1 ) ) # Explorer.DataFrame &lt; [ rows : 2 , columns : 2 ] a string [ &quot;b&quot; , &quot;c&quot; ] b integer [ 2 , 3 ] &gt;","ref":"Explorer.DataFrame.html#filter/2","title":"Explorer.DataFrame.filter/2","type":"function"},{"doc":"Creates a new dataframe from a map of lists. Lists must be the same length. This function calls Explorer.Series.from_list/2 so lists must conform to the requirements for making a series. Options backend - The Explorer backend to use. Defaults to the value returned by Explorer.default_backend/0 . Examples iex&gt; Explorer.DataFrame . from_map ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] } ) # Explorer.DataFrame &lt; [ rows : 2 , columns : 2 ] floats float [ 1.0 , 2.0 ] ints integer [ 1 , nil ] &gt;","ref":"Explorer.DataFrame.html#from_map/2","title":"Explorer.DataFrame.from_map/2","type":"function"},{"doc":"Returns the groups of a dataframe.","ref":"Explorer.DataFrame.html#groups/1","title":"Explorer.DataFrame.groups/1","type":"function"},{"doc":"Returns the first n rows of the dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . head ( df ) # Explorer.DataFrame &lt; [ rows : 5 , columns : 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 ] cement integer [ 5 , 177 , 2598 , 0 , 204 ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 ] &gt;","ref":"Explorer.DataFrame.html#head/2","title":"Explorer.DataFrame.head/2","type":"function"},{"doc":"Join two tables.","ref":"Explorer.DataFrame.html#join/3","title":"Explorer.DataFrame.join/3","type":"function"},{"doc":"Creates and modifies columns. Columns are added as keyword list arguments. New variables overwrite existing variables of the same name. Column names are coerced from atoms to strings. Examples You can pass in a list directly as a new column: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . mutate ( df , c : [ 4 , 5 , 6 ] ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c integer [ 4 , 5 , 6 ] &gt; Or you can pass in a series: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; s = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.DataFrame . mutate ( df , c : s ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c integer [ 4 , 5 , 6 ] &gt; Or you can invoke a callback on the dataframe: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ 4 , 5 , 6 ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . mutate ( df , c : &amp; Explorer.Series . add ( &amp;1 [ &quot;a&quot; ] , &amp;1 [ &quot;b&quot; ] ) ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 3 ] a integer [ 4 , 5 , 6 ] b integer [ 1 , 2 , 3 ] c integer [ 5 , 7 , 9 ] &gt; You can overwrite existing columns: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . mutate ( df , a : [ 4 , 5 , 6 ] ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] a integer [ 4 , 5 , 6 ] b integer [ 1 , 2 , 3 ] &gt; Alternatively, all of the above works with a map instead of a keyword list: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . mutate ( df , %{ &quot;c&quot; =&gt; [ 4 , 5 , 6 ] } ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c integer [ 4 , 5 , 6 ] &gt;","ref":"Explorer.DataFrame.html#mutate/2","title":"Explorer.DataFrame.mutate/2","type":"function"},{"doc":"Returns the number of columns in the dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . n_cols ( df ) 10","ref":"Explorer.DataFrame.html#n_cols/1","title":"Explorer.DataFrame.n_cols/1","type":"function"},{"doc":"Returns the number of rows in the dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . n_rows ( df ) 1094","ref":"Explorer.DataFrame.html#n_rows/1","title":"Explorer.DataFrame.n_rows/1","type":"function"},{"doc":"Gets the names of the dataframe columns. Examples iex&gt; df = Explorer.DataFrame . from_map ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , 2 ] } ) iex&gt; Explorer.DataFrame . names ( df ) [ &quot;floats&quot; , &quot;ints&quot; ]","ref":"Explorer.DataFrame.html#names/1","title":"Explorer.DataFrame.names/1","type":"function"},{"doc":"Extracts a single column as a series. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pull ( df , &quot;total&quot; ) # Explorer.Series &lt; integer [ 1094 ] [ 2308 , 1254 , 32500 , 141 , 7924 , 41 , 143 , 51246 , 1150 , 684 , 106589 , 18408 , 8366 , 451 , 7981 , 16345 , 403 , 17192 , 30222 , 147 , 1388 , 166 , 133 , 5802 , 1278 , 114468 , 47 , 2237 , 12030 , 535 , 58 , 1367 , 145806 , 152 , 152 , 72 , 141 , 19703 , 2393248 , 20773 , 44 , 540 , 19 , 2064 , 1900 , 5501 , 10465 , 2102 , 30428 , 18122 , ... ] &gt;","ref":"Explorer.DataFrame.html#pull/2","title":"Explorer.DataFrame.pull/2","type":"function"},{"doc":"Reads a delimited file into a dataframe. Options delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) dtypes - A keyword list of [column_name: dtype] . If nil , dtypes are imputed from the first 1000 rows. (default: nil ) header? - Does the file have a header of column names as the first row or not? (default: true ) max_rows - Maximum number of lines to read. (default: Inf ) names - A list of column names. Must match the width of the dataframe. (default: nil) null_character - The string that should be interpreted as a nil value. (default: &quot;NA&quot; ) skip_rows - The number of lines to skip at the beginning of the file. (default: 0 ) with_columns - A list of column names to keep. If present, only these columns are read into the dataframe. (default: nil )","ref":"Explorer.DataFrame.html#read_csv/2","title":"Explorer.DataFrame.read_csv/2","type":"function"},{"doc":"Similar to read_csv/2 but raises if there is a problem reading the CSV.","ref":"Explorer.DataFrame.html#read_csv!/2","title":"Explorer.DataFrame.read_csv!/2","type":"function"},{"doc":"Renames columns. To apply a function to a subset of columns, see rename_with/3 . Examples You can pass in a list of new names: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] } ) iex&gt; Explorer.DataFrame . rename ( df , [ &quot;c&quot; , &quot;d&quot; ] ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] c string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] d integer [ 1 , 3 , 1 ] &gt; Or you can rename individual columns using keyword args: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] } ) iex&gt; Explorer.DataFrame . rename ( df , a : &quot;first&quot; ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] first string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 1 , 3 , 1 ] &gt; Or you can rename individual columns using a map: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] } ) iex&gt; Explorer.DataFrame . rename ( df , %{ &quot;a&quot; =&gt; &quot;first&quot; } ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] first string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 1 , 3 , 1 ] &gt;","ref":"Explorer.DataFrame.html#rename/2","title":"Explorer.DataFrame.rename/2","type":"function"},{"doc":"Renames columns with a function. Examples If no columns are specified, it will apply the function to all column names: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , &amp; String . upcase / 1 ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 ] YEAR integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] COUNTRY string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] TOTAL integer [ 2308 , 1254 , 32500 , 141 , 7924 , &quot;...&quot; ] SOLID_FUEL integer [ 627 , 117 , 332 , 0 , 0 , &quot;...&quot; ] LIQUID_FUEL integer [ 1601 , 953 , 12381 , 141 , 3649 , &quot;...&quot; ] GAS_FUEL integer [ 74 , 7 , 14565 , 0 , 374 , &quot;...&quot; ] CEMENT integer [ 5 , 177 , 2598 , 0 , 204 , &quot;...&quot; ] GAS_FLARING integer [ 0 , 0 , 2623 , 0 , 3697 , &quot;...&quot; ] PER_CAPITA float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , &quot;...&quot; ] BUNKER_FUELS integer [ 9 , 7 , 663 , 0 , 321 , &quot;...&quot; ] &gt; A callback can be used to filter the column names that will be renamed, similarly to select/3 : iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , &amp; String . trim_trailing ( &amp;1 , &quot;_fuel&quot; ) , &amp; String . ends_with? ( &amp;1 , &quot;_fuel&quot; ) ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , &quot;...&quot; ] solid integer [ 627 , 117 , 332 , 0 , 0 , &quot;...&quot; ] liquid integer [ 1601 , 953 , 12381 , 141 , 3649 , &quot;...&quot; ] gas integer [ 74 , 7 , 14565 , 0 , 374 , &quot;...&quot; ] cement integer [ 5 , 177 , 2598 , 0 , 204 , &quot;...&quot; ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , &quot;...&quot; ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , &quot;...&quot; ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , &quot;...&quot; ] &gt; Or you can just pass in the list of column names you'd like to apply the function to: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , &amp; String . upcase / 1 , [ &quot;total&quot; , &quot;cement&quot; ] ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] TOTAL integer [ 2308 , 1254 , 32500 , 141 , 7924 , &quot;...&quot; ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , &quot;...&quot; ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , &quot;...&quot; ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , &quot;...&quot; ] CEMENT integer [ 5 , 177 , 2598 , 0 , 204 , &quot;...&quot; ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , &quot;...&quot; ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , &quot;...&quot; ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , &quot;...&quot; ] &gt;","ref":"Explorer.DataFrame.html#rename_with/3","title":"Explorer.DataFrame.rename_with/3","type":"function"},{"doc":"Selects a subset of columns by name. Can optionally return all but the named columns if :drop is passed as the last argument. Examples You can select columns with a list of names: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . select ( df , [ &quot;a&quot; ] ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 1 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] &gt; Or you can use a callback function that takes the dataframe's names as its first argument: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . select ( df , &amp; String . starts_with? ( &amp;1 , &quot;b&quot; ) ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 1 ] b integer [ 1 , 2 , 3 ] &gt; If you pass :drop as the third argument, it will return all but the named columns: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . select ( df , [ &quot;b&quot; ] , :drop ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 1 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] &gt;","ref":"Explorer.DataFrame.html#select/3","title":"Explorer.DataFrame.select/3","type":"function"},{"doc":"Gets the shape of the dataframe as a {height, width} tuple. Examples iex&gt; df = Explorer.DataFrame . from_map ( %{ floats : [ 1.0 , 2.0 , 3.0 ] , ints : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . shape ( df ) { 3 , 2 }","ref":"Explorer.DataFrame.html#shape/1","title":"Explorer.DataFrame.shape/1","type":"function"},{"doc":"Subset a continuous set of rows. Negative offset will be counted from the end of the dataframe.","ref":"Explorer.DataFrame.html#slice/3","title":"Explorer.DataFrame.slice/3","type":"function"},{"doc":"Returns the last n rows of the dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . tail ( df ) # Explorer.DataFrame &lt; [ rows : 5 , columns : 10 ] year integer [ 2014 , 2014 , 2014 , 2014 , 2014 ] country string [ &quot;VIET NAM&quot; , &quot;WALLIS AND FUTUNA ISLANDS&quot; , &quot;YEMEN&quot; , &quot;ZAMBIA&quot; , &quot;ZIMBABWE&quot; ] total integer [ 45517 , 6 , 6190 , 1228 , 3278 ] solid_fuel integer [ 19246 , 0 , 137 , 132 , 2097 ] liquid_fuel integer [ 12694 , 6 , 5090 , 797 , 1005 ] gas_fuel integer [ 5349 , 0 , 581 , 0 , 0 ] cement integer [ 8229 , 0 , 381 , 299 , 177 ] gas_flaring integer [ 0 , 0 , 0 , 0 , 0 ] per_capita float [ 0.49 , 0.44 , 0.24 , 0.08 , 0.22 ] bunker_fuels integer [ 761 , 1 , 153 , 33 , 9 ] &gt;","ref":"Explorer.DataFrame.html#tail/2","title":"Explorer.DataFrame.tail/2","type":"function"},{"doc":"Subset rows with a list of indices.","ref":"Explorer.DataFrame.html#take/2","title":"Explorer.DataFrame.take/2","type":"function"},{"doc":"Converts a dataframe to a map. By default, the constituent series of the dataframe are converted to Elixir lists. Examples iex&gt; df = Explorer.DataFrame . from_map ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] } ) iex&gt; Explorer.DataFrame . to_map ( df ) %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] }","ref":"Explorer.DataFrame.html#to_map/2","title":"Explorer.DataFrame.to_map/2","type":"function"},{"doc":"Writes a dataframe to a delimited file. Options header? - Should the column names be written as the first line of the file? (default: true ) delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; )","ref":"Explorer.DataFrame.html#write_csv/3","title":"Explorer.DataFrame.write_csv/3","type":"function"},{"doc":"Similar to write_csv/3 but raises if there is a problem reading the CSV.","ref":"Explorer.DataFrame.html#write_csv!/3","title":"Explorer.DataFrame.write_csv!/3","type":"function"},{"doc":"","ref":"Explorer.DataFrame.html#t:data/0","title":"Explorer.DataFrame.data/0","type":"type"},{"doc":"","ref":"Explorer.DataFrame.html#t:t/0","title":"Explorer.DataFrame.t/0","type":"type"},{"doc":"","ref":"Explorer.Datasets.html","title":"Explorer.Datasets","type":"module"},{"doc":"CO2 emissions from fossil fuels since 2010, by country Citation Boden, T.A., G. Marland, and R.J. Andres. 2013. Global, Regional, and National Fossil-Fuel CO2 Emissions. Carbon Dioxide Information Analysis Center, Oak Ridge National Laboratory, U.S. Department of Energy, Oak Ridge, Tenn., U.S.A. doi 10.3334/CDIAC/00001_V2013","ref":"Explorer.Datasets.html#fossil_fuels/0","title":"Explorer.Datasets.fossil_fuels/0","type":"function"},{"doc":"The Explorer backend for Polars.","ref":"Explorer.PolarsBackend.html","title":"Explorer.PolarsBackend","type":"module"},{"doc":"Polars backend for Explorer.DataFrame .","ref":"Explorer.PolarsBackend.DataFrame.html","title":"Explorer.PolarsBackend.DataFrame","type":"module"},{"doc":"","ref":"Explorer.PolarsBackend.DataFrame.html#t:t/0","title":"Explorer.PolarsBackend.DataFrame.t/0","type":"type"},{"doc":"Polars backend for Explorer.Series .","ref":"Explorer.PolarsBackend.Series.html","title":"Explorer.PolarsBackend.Series","type":"module"},{"doc":"","ref":"Explorer.PolarsBackend.Series.html#name/1","title":"Explorer.PolarsBackend.Series.name/1","type":"function"},{"doc":"","ref":"Explorer.PolarsBackend.Series.html#rename/2","title":"Explorer.PolarsBackend.Series.rename/2","type":"function"},{"doc":"","ref":"Explorer.PolarsBackend.Series.html#t:t/0","title":"Explorer.PolarsBackend.Series.t/0","type":"type"},{"doc":"The Series struct and API. A series can be of the following data types: :float - 64-bit floating point number :integer - 64-bit signed integer :boolean - Boolean :string - UTF-8 encoded binary :date - Date type that unwraps to Elixir.Date :datetime - DateTime type that unwraps to Elixir.NaiveDateTime A series must consist of a single data type only. Series are nullable, but may not consist only of nils. Many functions only apply to certain dtypes. Where that is the case, you'll find a Supported dtypes section in the function documentation and the function will raise an ArgumentError if a series with an invalid dtype is used.","ref":"Explorer.Series.html","title":"Explorer.Series","type":"module"},{"doc":"Adds right to left, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float","ref":"Explorer.Series.html#add/2","title":"Explorer.Series.add/2","type":"function"},{"doc":"Checks equality between two entire series. Examples iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; Explorer.Series . all_equal? ( s1 , s2 ) true iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . all_equal? ( s1 , s2 ) false","ref":"Explorer.Series.html#all_equal?/2","title":"Explorer.Series.all_equal?/2","type":"function"},{"doc":"Returns the indices that would sort the series.","ref":"Explorer.Series.html#argsort/2","title":"Explorer.Series.argsort/2","type":"function"},{"doc":"Cast the series to another type. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :string ) # Explorer.Series &lt; string [ 3 ] [ &quot;1&quot; , &quot;2&quot; , &quot;3&quot; ] &gt;","ref":"Explorer.Series.html#cast/2","title":"Explorer.Series.cast/2","type":"function"},{"doc":"Creates a new dataframe with unique values and the count of each.","ref":"Explorer.Series.html#count/1","title":"Explorer.Series.count/1","type":"function"},{"doc":"Calculates the cumulative maximum of the series. Optionally, can fill in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :date :datetime","ref":"Explorer.Series.html#cum_max/2","title":"Explorer.Series.cum_max/2","type":"function"},{"doc":"Calculates the cumulative minimum of the series. Optionally, can fill in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :date :datetime","ref":"Explorer.Series.html#cum_min/2","title":"Explorer.Series.cum_min/2","type":"function"},{"doc":"Calculates the cumulative sum of the series. Optionally, can fill in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :boolean","ref":"Explorer.Series.html#cum_sum/2","title":"Explorer.Series.cum_sum/2","type":"function"},{"doc":"Returns the unique values of the series. NB : Does not maintain order.","ref":"Explorer.Series.html#distinct/1","title":"Explorer.Series.distinct/1","type":"function"},{"doc":"Divides left by right, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float","ref":"Explorer.Series.html#divide/2","title":"Explorer.Series.divide/2","type":"function"},{"doc":"Returns the data type of the series. A series can be of the following data types: :float - 64-bit floating point number :integer - 64-bit signed integer :boolean - Boolean :string - UTF-8 encoded binary :date - Date type that unwraps to Elixir.Date :datetime - DateTime type that unwraps to Elixir.NaiveDateTime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . dtype ( s ) :integer iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , nil , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . dtype ( s ) :string","ref":"Explorer.Series.html#dtype/1","title":"Explorer.Series.dtype/1","type":"function"},{"doc":"Returns boolean mask of left == right , element-wise. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . eq ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ true , true , false ] &gt;","ref":"Explorer.Series.html#eq/2","title":"Explorer.Series.eq/2","type":"function"},{"doc":"Fill missing values with the given strategy. Strategies :forward - replace nil with the previous value :backward - replace nil with the next value :max - replace nil with the series maximum :min - replace nil with the series minimum :mean - replace nil with the series mean Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :forward ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 2 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :backward ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 4 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :max ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 4 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :min ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 1 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :mean ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 2 , 4 ] &gt;","ref":"Explorer.Series.html#fill_missing/2","title":"Explorer.Series.fill_missing/2","type":"function"},{"doc":"Filters a series with a mask or callback.","ref":"Explorer.Series.html#filter/2","title":"Explorer.Series.filter/2","type":"function"},{"doc":"Creates a new series from a list. The list must consist of a single data type and nils only; however, the list may not only consist of nils. Options :backend - The backend to allocate the series on. Examples Explorer will infer the type from the values in the list. iex&gt; Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) # Explorer.Series &lt; integer [ 3 ] [ 1 , 2 , 3 ] &gt; Series are nullable, so you may also include nils. iex&gt; Explorer.Series . from_list ( [ 1.0 , nil , 2.5 , 3.1 ] ) # Explorer.Series &lt; float [ 4 ] [ 1.0 , nil , 2.5 , 3.1 ] &gt; Mixing data types will raise an ArgumentError. iex&gt; Explorer.Series . from_list ( [ 1 , 2.9 ] ) ** (ArgumentError) Cannot make a series from mismatched types. Type of 2.9 does not match inferred dtype integer.","ref":"Explorer.Series.html#from_list/2","title":"Explorer.Series.from_list/2","type":"function"},{"doc":"Converts a Nx.Tensor.t/0 to a series. Examples iex&gt; tensor = Nx . tensor ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . from_tensor ( tensor ) # Explorer.Series &lt; integer [ 3 ] [ 1 , 2 , 3 ] &gt;","ref":"Explorer.Series.html#from_tensor/2","title":"Explorer.Series.from_tensor/2","type":"function"},{"doc":"Returns the value of the series at the given index. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . get ( s , 2 ) &quot;c&quot;","ref":"Explorer.Series.html#get/2","title":"Explorer.Series.get/2","type":"function"},{"doc":"Returns boolean mask of left &gt; right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . gt ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ false , false , false ] &gt;","ref":"Explorer.Series.html#gt/2","title":"Explorer.Series.gt/2","type":"function"},{"doc":"Returns boolean mask of left &gt;= right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . gt_eq ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ true , true , false ] &gt;","ref":"Explorer.Series.html#gt_eq/2","title":"Explorer.Series.gt_eq/2","type":"function"},{"doc":"Returns the first N elements of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . head ( s ) # Explorer.Series &lt; integer [ 10 ] [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] &gt;","ref":"Explorer.Series.html#head/2","title":"Explorer.Series.head/2","type":"function"},{"doc":"Returns the length of the series. Examples iex&gt; s = Explorer.Series . from_list ( [ ~D[1999-12-31] , ~D[1989-01-01] ] ) iex&gt; Explorer.Series . length ( s ) 2","ref":"Explorer.Series.html#length/1","title":"Explorer.Series.length/1","type":"function"},{"doc":"Returns boolean mask of left &lt; right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . lt ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ false , false , true ] &gt;","ref":"Explorer.Series.html#lt/2","title":"Explorer.Series.lt/2","type":"function"},{"doc":"Returns boolean mask of left &lt;= right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . lt_eq ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ true , true , true ] &gt;","ref":"Explorer.Series.html#lt_eq/2","title":"Explorer.Series.lt_eq/2","type":"function"},{"doc":"Gets the maximum value of the series. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . max ( s ) 3 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . max ( s ) 3.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . max ( s ) ~D[2021-01-01] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . max ( s ) ~N[2021-01-01 00:00:00] iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . max ( s ) ** (ArgumentError) Explorer.Series.max/1 not implemented for dtype :string. Valid dtypes are [:integer, :float, :date, :datetime].","ref":"Explorer.Series.html#max/1","title":"Explorer.Series.max/1","type":"function"},{"doc":"Gets the mean value of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . mean ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . mean ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . mean ( s ) ** (ArgumentError) Explorer.Series.mean/1 not implemented for dtype :date. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#mean/1","title":"Explorer.Series.mean/1","type":"function"},{"doc":"Gets the median value of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . median ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . median ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . median ( s ) ** (ArgumentError) Explorer.Series.median/1 not implemented for dtype :date. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#median/1","title":"Explorer.Series.median/1","type":"function"},{"doc":"Gets the minimum value of the series. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . min ( s ) 1 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . min ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . min ( s ) ~D[1999-12-31] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . min ( s ) ~N[1999-12-31 00:00:00] iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . min ( s ) ** (ArgumentError) Explorer.Series.min/1 not implemented for dtype :string. Valid dtypes are [:integer, :float, :date, :datetime].","ref":"Explorer.Series.html#min/1","title":"Explorer.Series.min/1","type":"function"},{"doc":"Multiplies left and right, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float","ref":"Explorer.Series.html#multiply/2","title":"Explorer.Series.multiply/2","type":"function"},{"doc":"Returns the number of unique values in the series. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; , &quot;b&quot; ] ) iex&gt; Explorer.Series . n_distinct ( s ) 2","ref":"Explorer.Series.html#n_distinct/1","title":"Explorer.Series.n_distinct/1","type":"function"},{"doc":"Returns boolean mask of left != right , element-wise. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . neq ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ false , false , true ] &gt;","ref":"Explorer.Series.html#neq/2","title":"Explorer.Series.neq/2","type":"function"},{"doc":"Returns a boolean mask with true where the 'peaks' (series max or min, default max) are. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 4 , 1 , 4 ] ) iex&gt; Explorer.Series . peaks ( s ) # Explorer.Series &lt; boolean [ 5 ] [ false , false , true , false , true ] &gt;","ref":"Explorer.Series.html#peaks/2","title":"Explorer.Series.peaks/2","type":"function"},{"doc":"Raises a numeric series to the power of the exponent. Supported dtypes :integer :float","ref":"Explorer.Series.html#pow/2","title":"Explorer.Series.pow/2","type":"function"},{"doc":"Gets the given quantile of the series. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . quantile ( s , 0.2 ) 1 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ~D[2021-01-01] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ~N[2021-01-01 00:00:00] iex&gt; s = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ** (ArgumentError) Explorer.Series.quantile/2 not implemented for dtype :boolean. Valid dtypes are [:integer, :float, :date, :datetime].","ref":"Explorer.Series.html#quantile/2","title":"Explorer.Series.quantile/2","type":"function"},{"doc":"Reverses the series.","ref":"Explorer.Series.html#reverse/1","title":"Explorer.Series.reverse/1","type":"function"},{"doc":"Calculate the rolling max, given a window size and optional weight.","ref":"Explorer.Series.html#rolling_max/4","title":"Explorer.Series.rolling_max/4","type":"function"},{"doc":"Calculate the rolling mean, given a window size and optional weight.","ref":"Explorer.Series.html#rolling_mean/4","title":"Explorer.Series.rolling_mean/4","type":"function"},{"doc":"Calculate the rolling min, given a window size and optional weight.","ref":"Explorer.Series.html#rolling_min/4","title":"Explorer.Series.rolling_min/4","type":"function"},{"doc":"Calculate the rolling sum, given a window size and optional weight.","ref":"Explorer.Series.html#rolling_sum/4","title":"Explorer.Series.rolling_sum/4","type":"function"},{"doc":"Returns a random sample of the series. If given an integer as the second argument, it will return N samples. If given a float, it will return that proportion of the series. Can sample with or without replacement.","ref":"Explorer.Series.html#sample/3","title":"Explorer.Series.sample/3","type":"function"},{"doc":"Returns a slice of the series, with length elements starting at offset . Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , 1 , 2 ) # Explorer.Series &lt; integer [ 2 ] [ 2 , 3 ] &gt; Negative offsets count from the end of the series. iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , - 3 , 2 ) # Explorer.Series &lt; integer [ 2 ] [ 3 , 4 ] &gt; If the length would run past the end of the series, the result may be shorter than the length. iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , - 3 , 4 ) # Explorer.Series &lt; integer [ 3 ] [ 3 , 4 , 5 ] &gt;","ref":"Explorer.Series.html#slice/3","title":"Explorer.Series.slice/3","type":"function"},{"doc":"Sorts the series.","ref":"Explorer.Series.html#sort/2","title":"Explorer.Series.sort/2","type":"function"},{"doc":"Gets the standard deviation of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . std ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . std ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . std ( s ) ** (ArgumentError) Explorer.Series.std/1 not implemented for dtype :string. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#std/1","title":"Explorer.Series.std/1","type":"function"},{"doc":"Subtracts right from left, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float","ref":"Explorer.Series.html#subtract/2","title":"Explorer.Series.subtract/2","type":"function"},{"doc":"Gets the sum of the series. Supported dtypes :integer :float :boolean Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . sum ( s ) 6 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . sum ( s ) 6.0 iex&gt; s = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . sum ( s ) 2 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . sum ( s ) ** (ArgumentError) Explorer.Series.sum/1 not implemented for dtype :date. Valid dtypes are [:integer, :float, :boolean].","ref":"Explorer.Series.html#sum/1","title":"Explorer.Series.sum/1","type":"function"},{"doc":"Returns the last N elements of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . tail ( s ) # Explorer.Series &lt; integer [ 10 ] [ 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 ] &gt;","ref":"Explorer.Series.html#tail/2","title":"Explorer.Series.tail/2","type":"function"},{"doc":"Returns the elements at the given indices as a new series. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . take ( s , [ 0 , 2 ] ) # Explorer.Series &lt; string [ 2 ] [ &quot;a&quot; , &quot;c&quot; ] &gt;","ref":"Explorer.Series.html#take/2","title":"Explorer.Series.take/2","type":"function"},{"doc":"Takes every n th value in this series, returned as a new series.","ref":"Explorer.Series.html#take_every/2","title":"Explorer.Series.take_every/2","type":"function"},{"doc":"Converts a series to a list. Examples iex&gt; series = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_list ( series ) [ 1 , 2 , 3 ]","ref":"Explorer.Series.html#to_list/1","title":"Explorer.Series.to_list/1","type":"function"},{"doc":"Converts a series to a Nx.Tensor.t/0 . Options are passed directly to Nx.tensor/2 . Supported dtypes :float :integer Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_tensor ( s ) # Nx.Tensor &lt; s64 [ 3 ] [ 1 , 2 , 3 ] &gt; Tensor options can be passed directly to to_tensor/2 . iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_tensor ( s , names : [ :y ] , type : { :f , 64 } ) # Nx.Tensor &lt; f64 [ y : 3 ] [ 1.0 , 2.0 , 3.0 ] &gt;","ref":"Explorer.Series.html#to_tensor/2","title":"Explorer.Series.to_tensor/2","type":"function"},{"doc":"Gets the variance of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . var ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . var ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . var ( s ) ** (ArgumentError) Explorer.Series.var/1 not implemented for dtype :datetime. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#var/1","title":"Explorer.Series.var/1","type":"function"},{"doc":"","ref":"Explorer.Series.html#t:data/0","title":"Explorer.Series.data/0","type":"type"},{"doc":"","ref":"Explorer.Series.html#t:dtype/0","title":"Explorer.Series.dtype/0","type":"type"},{"doc":"","ref":"Explorer.Series.html#t:t/0","title":"Explorer.Series.t/0","type":"type"}]